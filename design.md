# ウェブアプリ設計：カメラ画像編集ツール

### 1. アプリケーションの目的と主な機能（UI/UXを考慮）

**目的:** 高校生が自分のカメラで撮影した画像を取り込み、**直感的なUI**で**解像度**や**階調**を手軽に調整できるツールを提供します。調整結果の**データ量変化**も視覚的に確認でき、いつでも**元の画像に戻せる**ようにすることで、画像編集の楽しさと仕組みを体験できるようにします。

**主な機能とUI/UXのポイント:**

1. **カメラ映像のリアルタイム表示と画像キャプチャ:**
    - **UI/UX:** アプリ起動後すぐにカメラ映像が表示され、大きな「**撮影**」ボタンで迷わずキャプチャできます。プレビュー画面は大きく表示し、操作の邪魔にならないようにします。
    - **機能:** デバイスのカメラ映像をリアルタイムでウェブページに表示。ユーザー操作（ボタンクリック）で、その時点の映像を静止画像として**キャプチャ**します。
2. **画像解像度の変更:**
    - **UI/UX:** スライダーで解像度を調整します。表示される画像のサイズは固定ですが、解像度を小さくすると画像が荒く（ピクセルが目立つように）表示され、視覚的にデータ量の変化を実感できます。
    - **機能:** キャプチャした画像の表示解像度（ピクセル数）を調整し、それに伴う画像の見た目と**データ量（理論値）をリアルタイムで更新表示**します。データ量は階調数にも依存して計算されます。
3. **画像階調の変更:**
    - **UI/UX:** 「グレースケール階調」と「RGB各チャンネル階調」の2つのモードをラジオボタンで選択できます。選択されたモードに応じて、階調数を調整するスライダーが表示され、リアルタイムで効果が反映されます。
    - **機能:** HTML Canvas APIを利用して、キャプチャした画像のピクセルデータを直接操作し、指定された階調数に量子化します。グレースケール変換後の階調調整、またはRGB各チャンネル独立での階調調整が可能です。階調変更は理論データ量に影響します。
4. **操作の取り消し（元に戻す）:**
    - **UI/UX:** 「**元に戻す**」ボタンは大きく分かりやすい位置に配置し、クリック一つで全ての調整が元の状態に戻るようにします。操作を取り消すことへの不安をなくします。
    - **機能:** 解像度、階調、フィルターの全ての変更を、キャプチャしたばかりの元の画像の状態に一括で戻します。

---

### 2. 技術スタック

- **フロントエンドフレームワーク:** React
- **UI コンポーネントライブラリ:** Material-UI (MUI)
- **画像処理:** HTML Canvas API
- **開発/デプロイ環境:** Docker (開発環境の標準化、本番デプロイ)
- **基本言語/技術:** HTML, CSS, JavaScript (ES6+)
- **カメラアクセス:** WebRTC (`navigator.mediaDevices.getUserMedia`)
- **画像描画/操作:** HTML Canvas API

---

### 3. アプリケーション構成

### 3.1. コンポーネント設計 (React)

高校生が使いやすいUI/UXを重視し、機能ごとにまとまりを意識したコンポーネント構成にします。

- **`App` (ルートコンポーネント):**
    - アプリケーション全体の**レイアウト**を管理します。MUIの`Container`や`Grid`を使って、コンテンツが画面中央に配置され、視覚的に整理されているようにします。
    - 主要な**グローバルステート**（例: キャプチャされた画像データ、現在の解像度設定、階調調整値など）を保持し、子コンポーネントにプロップスとして渡すか、Context API等で共有します。
- **`CameraCapture` コンポーネント:**
    - **役割:** カメラ映像の表示と静止画のキャプチャ。
    - **UI/UX:**
        - 大きな`<video>`要素でカメラ映像を**全画面に近い形**でプレビュー表示。
        - 下部または右側に、**MUIの`Fab`（Floating Action Button）のような大きな「撮影」ボタン**を配置し、視覚的に目立たせます。
        - 必要であれば、カメラ切り替え（前面/背面）ボタンもシンプルに配置します。
    - **機能:** `getUserMedia` を利用してカメラ映像を`<video>`要素にストリーミング。ユーザーが「撮影」ボタンをクリックすると、現在の`<video>`フレームを`<canvas>`にキャプチャし、その画像データ（またはCanvas参照）を親コンポーネントに渡します。
- **`ImageEditor` コンポーネント:**
    - **役割:** キャプチャした画像の表示、解像度・階調調整、データ量表示、元に戻す機能の提供。
    - **UI/UX:**
        - **画像を中央に大きく表示**する`<canvas>`要素が中心。
        - **サイドバーまたは下部に調整パネル**を設けます。パネルはタブやアコーディオンで「解像度」「階調（フィルター）」など項目を分け、UIの混雑を避けます。
        - **解像度調整:**
            - スライダーで解像度を調整します。スライダーの横に現在のピクセルサイズと元のサイズに対するパーセンテージを表示します。
            - リアルタイムで**データ量を更新表示**し、その横に「理論値」「非圧縮時」などの注意書きを表示します。
        - **階調調整:**
            - 「グレースケール階調」と「RGB各チャンネル階調」のラジオボタンを縦に配置します。
            - 選択されたモードに応じて、階調数を調整するスライダーが表示されます。スライダーの横に現在の階調数を表示します。
        - **「元に戻す」ボタン:** 調整パネルの目立つ位置（例: フッター部分）に、**MUI `Button`** を使って大きく配置します。アイコン（例: ↩️）も併用し、視認性を高めます。
- **MUI UIコンポーネントの活用:**
    - **レイアウト:** `Box`, `Container`, `Grid` を利用し、コンテンツの配置を整理。
    - **入力:** `Slider` (数値調整), `TextField` (直接入力), `Select` (オプション選択)。
    - **ボタン:** `Button`, `Fab` (主要アクション)。
    - **表示:** `Typography` (テキスト), `Paper` (パネルの背景)。
    - **タブ/アコーディオン:** `Tabs`, `Accordion` (調整パネルの整理)。

### 3.2. 状態管理 (React State / Context API)

- **画像データ:** キャプチャした元の画像データ（例: ImageDataオブジェクト）を親コンポーネント（`App`）のステートで保持します。Canvas APIのフィルターやピクセル操作を適用して、変更後の画像データを`<canvas>`に反映させます。
- **解像度設定:** `CameraCapture`と`ImageEditor`が共有する解像度設定値（幅、高さ）をステートで管理します。
- **階調設定:** 階調モード（なし、グレースケール、RGB）と階調数を`ImageEditor`コンポーネントのステートで管理します。
- **元の画像状態の記憶:**
    - 編集の起点となる、キャプチャ直後の元の`ImageData`オブジェクトをステートとして常に保持します。全ての編集は、この元の`ImageData`に対して行います。
    - **解像度:** キャプチャ時の初期解像度、またはユーザーが設定した初期カメラ解像度をステートとして別途保持します。

### 3.3. データフロー

1. **カメラ起動:** `App`コンポーネントがマウントされ、`CameraCapture`が`getUserMedia`を呼び出し、`<video>`タグにストリームを表示します。
2. **画像キャプチャ:** ユーザーが「撮影」ボタンをクリックすると、`CameraCapture`が`<video>`のフレームを一時的な`<canvas>`に描き、その画像データ（またはCanvas参照）を親（`App`）に渡します。
3. **画像表示と初期化:** `App`が受け取った画像データを`ImageEditor`に渡し、`ImageEditor`がそのデータを自身のメイン`<canvas>`に描画します。
4. **解像度変更:**
    - ユーザーが`ImageEditor`内の解像度スライダーやプリセットボタンを操作します。
    - `ImageEditor`のステートが更新され、それに基づいて表示用のメイン`<canvas>`の`width`と`height`が変更され、**元の画像が新しいサイズで再描画される**ため、**元の画像データを保持し、新しいサイズで`drawImage`を再実行する**ロジックが必要です。
    - 同時に、データ量計算関数が呼び出され、新しいデータ量が表示されます。
5. **階調変更:**
    - ユーザーが`ImageEditor`内の階調モードや階調数スライダーを操作します。
    - `ImageEditor`のステートが更新されます。
    - ピクセルごとのデータ操作が呼び出され、現在のキャンバスに対して指定された階調調整が適用され、再描画されます。
6. **「元に戻す」:**
    - ユーザーが「元に戻す」ボタンをクリックします。
    - `ImageEditor`内で、保持している**元の`ImageData`オブジェクトを使ってキャンバスを再描画**し、階調モードと階調数を初期状態に戻します。
    - 解像度設定に関するステートも初期値にリセットし、メイン`<canvas>`のサイズを再設定して画像を再描画します。

---

### 4. ディレクトリ構成

`.
├── public/                 # 静的ファイル (index.html, faviconなど)
│   └── index.html          # アプリケーションのエントリポイント
│   └── ...
├── src/                    # アプリケーションのソースコード
│   ├── assets/             # 静的アセット (画像、フォントなど)
│   │   └── images/
│   │   └── fonts/
│   ├── components/         # 再利用可能なUIコンポーネント
│   │   ├── CameraCapture/  # カメラ機能コンポーネントのディレクトリ
│   │   │   ├── CameraCapture.js
│   │   │   └── CameraCapture.module.css # または .js (emotion/styled)
│   │   ├── ImageEditor/    # 画像編集機能コンポーネントのディレクトリ
│   │   │   ├── ImageEditor.js
│   │   │   └── ImageEditor.module.css
│   │   ├── ui/             # より汎用的なUI要素 (例: CustomSlider.js)
│   │   └── ...
│   ├── hooks/              # カスタムフック (例: useCamera.js, useImageProcessing.js)
│   │   └── useCamera.js
│   │   └── useImageProcessor.js
│   ├── utils/              # ヘルパー関数やユーティリティ
│   │   ├── imageCalculations.js # データ量計算関数など
│   │   ├── constants.js     # 定数定義 (解像度プリセットなど)
│   │   └── imageFilters.js  # Canvas APIを使ったフィルター関数など
│   ├── styles/             # グローバルスタイルやMUIテーマ設定
│   │   ├── theme.js        # MUIのカスタムテーマ
│   │   └── global.css
│   ├── App.js              # ルートコンポーネント
│   ├── index.js            # アプリケーションのエントリファイル (React DOMのレンダリング)
│   └── reportWebVitals.js  # (Create React Appの場合)
│   └── setupTests.js       # (Create React Appの場合)
├── Dockerfile              # 本番用Dockerイメージ構築ファイル
├── package.json            # プロジェクトの依存関係とスクリプト
├── yarn.lock               # 依存関係のロックファイル (yarn使用時)
├── .env                    # 環境変数 (開発用)
├── .env.production         # 環境変数 (本番用)
├── .gitignore              # Git管理から除外するファイル/ディレクトリ
└── README.md               # プロジェクトの説明`

---

### 5. 各機能の実装詳細（コード例なし）

### 5.1. カメラ機能 (`CameraCapture` コンポーネント)

- **HTML要素の構成:** `video`タグを主要な要素とし、カメラ映像をリアルタイムで表示します。静止画キャプチャのための一時的な`canvas`タグも用意しますが、画面上には表示しません。撮影アクションを促すためのボタン（MUIの`Fab`など）を配置します。
- **JavaScriptロジック:** Reactのライフサイクル管理（`useEffect`）を利用して、コンポーネントのマウント時にユーザーのカメラにアクセスし、ストリームを`video`要素に設定します。撮影ボタンがクリックされた際には、`video`要素から現在のフレームを`canvas`に描画し、その画像データを取得して親コンポーネントに渡します。

### 5.2. 画像編集機能 (`ImageEditor` コンポーネント)

- **HTML要素の構成:** メインとなる`canvas`タグを配置し、これが画像を表示・編集する領域となります。この`canvas`に対してCanvas APIが操作を行います。解像度、階調、フィルター調整のためのMUIコンポーネント（`Slider`、`Select`、`Button`など）を配置し、視覚的に分かりやすい調整パネルを構成します。データ量を表示するためのテキスト要素も用意します。
- **JavaScriptロジック:**
    - **状態管理:** 画像データ、解像度、階調モード、階調数をReactのステートで管理します。元の画像データ(`ImageData`)を保持するためのステートも重要です。
    - **Canvas APIによる画像処理:** キャプチャした画像がセットされた後、`processingCanvas`に描画します。階調調整が行われるたびに、`getImageData`でピクセルデータを取得して直接操作し、`putImageData`でキャンバスに結果を反映させます。その後、`processingCanvas`の内容を`displayCanvas`に拡大描画します（スムージング無効）。
    - **解像度変更:** ユーザーの解像度設定に応じて、`processingCanvas`の物理的な幅と高さを変更します。同時に、保持している元の画像データを新しいサイズの`processingCanvas`に再描画します。
    - **「元に戻す」機能:** ユーザーが「元に戻す」ボタンをクリックすると、保持している元の`ImageData`を`processingCanvas`に再描画して階調・解像度に関する全ての調整ステートを初期値に戻します。

### 5.3. データ量計算

- **JavaScript関数:** 幅、高さ、チャンネル数、各チャンネルのビット数を受け取り、非圧縮の画像データ量をバイト単位で計算する純粋な関数を定義します。
- **Reactロジック:** `ImageEditor`コンポーネント内で、現在の画像解像度（幅と高さ）と階調モード、階調数のステートが変更されるたびに計算関数を呼び出します。計算結果をバイト単位で表示し、その隣に適切な接頭辞（KB, MBなど）を付けた形式で表示します。

---

### 6. 今後のステップ

1. **プロジェクトの初期設定:** Vite でReactプロジェクトを作成し、MUIをインストールします。
2. **基本UIの構築:** `App`、`CameraCapture`、`ImageEditor`コンポーネントの骨格とMUIを使った分かりやすいUIレイアウトを作成します。
3. **カメラ機能の実装:** `CameraCapture`でカメラ映像の表示と画像キャプチャ機能を完成させます。
4. **Canvas APIによる画像処理実装:** キャプチャした画像を`ImageEditor`のCanvasに表示し、Canvas APIで階調調整を実装します。
5. **解像度変更とデータ量計算:** 解像度変更UIと、それに応じたCanvasのリサイズ、そしてデータ量計算・表示機能を実装します。
6. **「元に戻す」機能の実装:** Canvas APIの機能と解像度ステートのリセットを組み合わせて実装します。
7. **Docker化:** 開発環境と本番デプロイ用のDockerfileを作成し、動作を確認します。
8. **ユーザーテスト:** 高校生などのターゲットユーザーに実際に触ってもらい、フィードバックを元にUI/UXを改善します。

この詳細な設計があれば、開発チームは明確な指針を持ってプロジェクトを進めることができるでしょう。